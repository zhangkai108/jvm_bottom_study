# redis
## redis模型
C:一致性
A:可用性
P:分区容错性
常见代表：
CA:没有容错性就不能分在不同机器上，oracle
CP:追求强一致性，可能请求很久，zookeeper
AP:追求最终一致性，erueka
redis集群是AP模型
## 持久化策略
RDB:快照的方式，对redis中的数据执行周期性的持久化，通过配置文件中设置检查间隔时间与备份触发条件来对数据进行周期性的持久化
AOF:的持久化，AOF机制对每条写入命令作为日志记录，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集。
对比:AOF日志文件比单个快照大，但是AOF保存的数据更为完整，如果都开启默认优先AOF
## 缓存穿透
一直查询数据库中没有的数据，然后查不到数据，缓存中自然没有，然后假如qps特别大，就会造成缓存穿透
解决方案：
- 布隆过滤器：利用hash算法，算格子位置，然后置为1
缺点：因为存在hash冲突，所以只能判断数据是否一定不存在，而无法判断数据是否一定存在
有点：快
- 缓存空对象：当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；
缺点：占用空间
## 缓存雪崩
缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况
解决方案：
- redis集群：既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作
- 限流降级：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待
- 数据预热：数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中
## 集群（分布式集群）
一般6个搭建， 3个master和3个salve，三个master实现分布式存储，比如60个数据，每个master上存20个数据
- 主从复制过程：为每一个master节点准备一个slave节点
  1. 从服务器连接主服务器，发送SYNC命令；
  2. 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；
  3. 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；
  4. 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；
  5. 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；
  6. 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；

  注意说明：
    针对与RDB方式保存有分为 save 和 bgsave 命令，两者的区别在于save为同步保存，即存在阻塞；而bgsave为异步保存，非阻塞。在上面原理中有给出redis主从复制采用的是bgsave的方式，如若不清楚也可以看下面log日志中的内容。
    ./src/redis-server redis-7000.conf
    主从复制启动，这种情况如果master一旦挂了，slave无法进行增量同步，需要开启哨兵模式
## 哨兵模式：
[哨兵模式启动详细](https://www.cnblogs.com/guolianyu/p/10249687.html);
## 集群脑裂：
- 原因：网络波动导致假死
- 解决方案：
  - 首先保证光缆，交换机之类的硬件质量比较好，接口接好
  - 在slaver切换的时候不在检查到老的master出现问题后马上切换，而是在休眠一段足够的时间，确保老的master已经获知变更并且做了相关的shutdown清理工作了然后再注册成为master就能避免这类问题了，
  这个休眠时间一般定义为与zookeeper定义的超时时间就够了，但是这段时间内系统可能是不可用的，但是相对于数据不一致的后果我想还是值得的
  - [zk假死](https://www.cnblogs.com/rainy-shurun/p/5414110.html)

